package it.unibo.unori.controller.json;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import java.util.Optional;

import com.google.gson.JsonIOException;
import com.google.gson.JsonSyntaxException;

import it.unibo.unori.model.maps.GameMap;
import it.unibo.unori.model.maps.WorldBuilder;
import it.unibo.unori.model.maps.WorldBuilder.MAPS;

public class WorldLoader {
    /**
     * This is the path to the file were is serialized the GameMap of the house containing 4 NPCs around a table.
     */
    public static final String FOUR_NPC_ROOM = "res/maps/House.json";
    /**
     * This is the path to the file were is serialized the GameMap of the shop.
     */
    public static final String SHOP = "res/maps/Shop.json";
    /**
     * This is the path to the file were is serialized the GameMap of the church.
     */
    public static final String CHURCH = "res/maps/Church.json";
    /**
     * This is the path to the file were is serialized the GameMap of the village.
     */
    public static final String VILLAGE = "res/maps/Village.json";
    /**
     * This is the path to the file were is serialized the GameMap of the small passage in the overworld, between the
     * village and the dungeon entrance.
     */
    public static final String PASSAGE = "res/maps/Passage.json";
    /**
     * This is the path to the file were is serialized the GameMap of the dungeon entrance.
     */
    public static final String DUNGEON_ENTRANCE = "res/maps/DungeonEntrance.json";

    private final Map<String, GameMap> maps;
    private final JsonFileManager fileManager;

    /**
     * Default constructor.
     */
    public WorldLoader() {
        this.maps = new HashMap<>();
        this.fileManager = new JsonFileManager();
    }

    /**
     * This main simply serializes the default maps generated by {@link it.unibo.unori.model.maps.WorldBuilder}.
     * 
     * @throws IOException
     *             if an error occurs
     * @throws FileNotFoundException
     *             if the file exists but is a directory rather than a regular file, does not exist but cannot be
     *             created, or cannot be opened for any other reason
     * @throws SecurityException
     *             if a security manager exists and its checkWrite method denies write access to the file
     * @throws JsonIOException
     *             if there was a problem writing to the writer
     */
    public static void main() throws IOException {
        final WorldBuilder wb = new WorldBuilder();
        final JsonFileManager fm = new JsonFileManager();
        wb.buildWorld();
        fm.saveMap(wb.getGameMap(MAPS.CITY), VILLAGE);
        fm.saveMap(wb.getGameMap(MAPS.SHOP), SHOP);
        fm.saveMap(wb.getGameMap(MAPS.CHURCH), CHURCH);
        fm.saveMap(wb.getGameMap(MAPS.HOUSE), FOUR_NPC_ROOM);
        fm.saveMap(wb.getGameMap(MAPS.AISLE), PASSAGE);
        fm.saveMap(wb.getGameMap(MAPS.DENTRANCE), DUNGEON_ENTRANCE);
    }

    /**
     * This method loads a GameMap serialized on a specified file. The map is probably not linked to other maps.
     * 
     * @param path
     *            the path were to find the file
     * @return the GameMap deserialized
     * @throws IOException
     *             if an error occurs
     * @throws FileNotFoundException
     *             if the file does not exist, is a directory rather than a regular file, or for some other reason
     *             cannot be opened for reading
     * @throws JsonIOException
     *             if there was a problem reading from the Reader
     * @throws JsonSyntaxException
     *             if the file does not contain a valid representation for an object of type
     */
    public GameMap loadMap(final String path) throws IOException {
        if (!this.maps.containsKey(path)) {
            this.maps.put(path, this.fileManager.loadMap(path));
        }
        return this.maps.get(path);
    }

    /**
     * This method load the whole world from default files, linking all the maps together and returning the map of the
     * village (linked to the others).
     * 
     * @return the map of the village, linked to the other maps of the world
     * @throws IOException
     *             if an error occurs
     * @throws FileNotFoundException
     *             if the file does not exist, is a directory rather than a regular file, or for some other reason
     *             cannot be opened for reading
     * @throws JsonIOException
     *             if there was a problem reading from the Reader
     * @throws JsonSyntaxException
     *             if the file does not contain a valid representation for an object of type
     */
    public GameMap loadWorld() throws IOException {
        final WorldBuilder builder = new WorldBuilder();
        builder.setGameMap(convertStandardPathToMapName(VILLAGE), this.fileManager.loadMap(VILLAGE));
        builder.setGameMap(convertStandardPathToMapName(SHOP), this.fileManager.loadMap(SHOP));
        builder.setGameMap(convertStandardPathToMapName(CHURCH), this.fileManager.loadMap(CHURCH));
        builder.setGameMap(convertStandardPathToMapName(FOUR_NPC_ROOM), this.fileManager.loadMap(FOUR_NPC_ROOM));
        builder.setGameMap(convertStandardPathToMapName(PASSAGE), this.fileManager.loadMap(PASSAGE));
        builder.setGameMap(convertStandardPathToMapName(DUNGEON_ENTRANCE), this.fileManager.loadMap(DUNGEON_ENTRANCE));

        return builder.buildWorld();
    }

    /**
     * This method converts default-paths string to the enum used to identify the types of maps.
     * 
     * @param path
     *            the default-paths string of the serialized map
     * @return the respective MAPS name
     */
    private MAPS convertStandardPathToMapName(final String path) {
        Optional<MAPS> mapName;
        switch (path) {
        case FOUR_NPC_ROOM:
            mapName = Optional.of(MAPS.HOUSE);
            break;
        case SHOP:
            mapName = Optional.of(MAPS.SHOP);
            break;
        case CHURCH:
            mapName = Optional.of(MAPS.CHURCH);
            break;
        case VILLAGE:
            mapName = Optional.of(MAPS.CITY);
            break;
        case PASSAGE:
            mapName = Optional.of(MAPS.AISLE);
            break;
        case DUNGEON_ENTRANCE:
            mapName = Optional.of(MAPS.DENTRANCE);
            break;
        default:
            mapName = Optional.empty();
            break;
        }
        return mapName.orElseThrow(() -> new IllegalArgumentException());
    }
}
